{% extends 'base.html' %}

{% block title %}Documents - Nimbus{% endblock %}

{% block content %}
  <div class="card mb-4">
    <div class="card-header text-center bg-primary text-white"><i class="bi bi-folder"></i> Documents</div>
    <div class="card-body">
      <div class="row g-4">
        <!-- Upload Section (top) -->
        <div class="col-12">
          <div class="card shadow-sm mb-4">
            <div class="card-header bg-success text-white text-center">
              <i class="bi bi-upload"></i> Upload File
            </div>
            <div class="card-body">
              <form method="post" action="{{ url_for('documents.upload_document') }}" enctype="multipart/form-data">
                <div class="mb-3">
                  <label for="file" class="form-label">Choose file</label>
                  <input type="file" name="file" id="file" class="form-control" required>
                </div>
                <button type="submit" class="btn btn-success"><i class="bi bi-upload"></i> Upload</button>
              </form>
            </div>
          </div>
        </div>

  <!-- Files List (full width) -->
  <div class="col-12">
          <div class="card shadow-sm">
            <div class="card-header bg-dark text-white text-center">
              <i class="bi bi-folder2-open"></i> Uploaded Files
            </div>
            <div class="card-body">
              <table class="table table-hover">
                <thead class="table-light">
                  <tr>
                    <th>Filename</th>
                    <th>Uploader</th>
                    <th>Size</th>
                    <th>Parsed</th>
                    <th>Splitter</th>
                    <th>Embeddings</th>
                    <th>Enabled</th>
                    <th>Actions</th>
                  </tr>
                </thead>
                <tbody>
                {% for f in files %}
                  <tr>
                    <td><a href="{{ url_for('documents.uploaded_file', filename=f.filename) }}">{{ f.filename }}</a></td>
                    <td>{{ f.uploader }}</td>
                    <td>{{ (f.size / 1024)|round(1) }} KB</td>
                    <td class="text-center">
                      <!-- Parse column: show parser selector when unparsed; after parsed show check + parser used -->
                      {% if f.parsing_status != 'Parsed' %}
                        <form method="post" action="{{ url_for('documents.parse_document', filename=f.filename) }}" class="d-inline parse-form">
                          <select name="parser" class="form-select form-select-sm d-inline-block" style="width:auto;">
                            <option value="pymupdf">PyMuPDF</option>
                            <option value="pdfplumber">pdfplumber</option>
                            <option value="unstructured">Unstructured</option>
                            <option value="ocr">OCR (Images)</option>
                          </select>
                          <button class="btn btn-primary btn-sm" title="Parse">
                            <i class="bi bi-play-fill"></i>
                          </button>
                        </form>
                      {% else %}
                        <div class="d-flex flex-column align-items-center">
                          <span class="text-success"><i class="bi bi-check-circle-fill" style="font-size:1.2rem"></i></span>
                          {% if f.parser_name %}
                            <small class="text-muted">Parsed with: <strong class="text-info">{{ f.parser_name }}</strong></small>
                          {% elif f.parsing_status %}
                            <small class="text-muted">Parsed</small>
                          {% endif %}
                        </div>
                      {% endif %}
                    </td>
                    <td class="text-center">
                      {# Splitter column: show controls when parsed but not splitted, else show which splitter used with green tick #}
                      {% if f.parsing_status == 'Parsed' and not f.splitter_name %}
                        <form method="post" action="{{ url_for('documents.split_document', filename=f.filename) }}" class="d-inline-block splitter-form">
                          <select name="splitter" class="form-select form-select-sm d-inline-block" style="width:auto;">
                            <option value="recursive">Recursive</option>
                            <option value="token">Token</option>
                            <option value="semantic">Semantic</option>
                          </select>
                          <input type="number" name="max_chars" value="1000" class="form-control form-control-sm d-inline-block" style="width:90px;" title="max chars / tokens">
                          <input type="number" name="overlap" value="200" class="form-control form-control-sm d-inline-block" style="width:80px;" title="overlap">
                          <button class="btn btn-secondary btn-sm" title="Split">
                            <i class="bi bi-scissors"></i>
                          </button>
                        </form>
                      {% elif f.splitter_name %}
                        <div class="d-flex flex-column align-items-center">
                          <span class="text-success"><i class="bi bi-check-circle-fill" style="font-size:1.2rem"></i></span>
                          <small class="text-muted">Splitter: <strong class="text-info">{{ f.splitter_name }}</strong></small>
                        </div>
                      {% else %}
                        <span class="text-muted">-</span>
                      {% endif %}
                    </td>
                    <td class="text-center">
                      {# Embedding model: only show when document is parsed AND split #}
                      {% if f.parsing_status == 'Parsed' and f.splitter_name %}
                        {% if f.has_embeddings %}
                          <div class="d-flex flex-column align-items-center">
                            <span class="text-success"><i class="bi bi-check-circle-fill" style="font-size:1.2rem"></i></span>
                            {% if f.embeddings_model %}
                              <small class="text-muted">Model: <strong class="text-info">{{ f.embeddings_model }}</strong></small>
                            {% else %}
                              <small class="text-muted">Embeddings</small>
                            {% endif %}
                          </div>
                        {% else %}
                          <form method="post" action="{{ url_for('documents.embeddings_document', filename=f.filename) }}" class="d-inline-block">
                            <select name="model" class="form-select form-select-sm d-inline-block me-2" style="width:auto;">
                              <option value="nomic_embed_text" {% if f.embeddings_model == 'nomic_embed_text' %}selected{% endif %}>nomic-embed-text</option>
                              <option value="mxbai_embed_large" {% if f.embeddings_model == 'mxbai_embed_large' %}selected{% endif %}>mxbai-embed-large</option>
                              <option value="all_minilm" {% if f.embeddings_model == 'all_minilm' %}selected{% endif %}>all-minilm</option>
                            </select>
                            <button class="btn btn-outline-primary btn-sm" title="Generate embeddings">
                              <i class="bi bi-graph-up"></i>
                            </button>
                          </form>
                        {% endif %}
                      {% else %}
                        <span class="text-muted">-</span>
                      {% endif %}
                    </td>
                    <td>
                      <form method="post" action="{{ url_for('documents.toggle_enable', filename=f.filename) }}" class="d-inline toggle-form">
                        <input type="hidden" name="_method" value="toggle">
                        <button class="btn btn-outline-{{ 'success' if f.enabled else 'secondary' }} btn-sm">{{ 'Enabled' if f.enabled else 'Disabled' }}</button>
                      </form>
                    </td>
                    <td>
                      <button class="btn btn-info btn-sm me-1" onclick="previewDocument('{{ f.filename }}')" title="Preview Document" {% if f.parsing_status != 'Parsed' %}disabled{% endif %}>
                        <i class="bi bi-eye-fill"></i>
                      </button>
                      <form method="post" action="{{ url_for('documents.delete_document', filename=f.filename) }}" style="display:inline">
                        <button class="btn btn-danger btn-sm" title="Delete">
                          <i class="bi bi-trash-fill"></i>
                        </button>
                      </form>
                    </td>
                  </tr>
                {% else %}
                  <tr><td colspan="8">No files uploaded yet.</td></tr>
                {% endfor %}
                </tbody>
              </table>
            </div>
          </div>
        </div>
        
      </div>
    </div>
  </div>

  <!-- Document Preview Modal -->
  <div class="modal fade" id="previewModal" tabindex="-1" aria-labelledby="previewModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-fullscreen">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="previewModalLabel">
            <i class="bi bi-file-earmark-pdf"></i> <span id="previewFilename"></span>
          </h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body p-0" style="height: calc(100vh - 120px);">
          <div id="previewLoading" class="text-center py-5">
            <div class="spinner-border text-primary" role="status">
              <span class="visually-hidden">Loading...</span>
            </div>
            <p class="mt-3">Loading document preview...</p>
          </div>
          
          <!-- PDF Viewer -->
          <iframe id="pdfViewer" style="width: 100%; height: 100%; border: none; display: none;"></iframe>
          
          <!-- Text Content (for non-PDF files) -->
          <div id="textContent" style="display:none; height: 100%; overflow-y: auto; padding: 3rem 4rem; background: #f8f9fa;">
            <div style="max-width: 900px; margin: 0 auto; background: white; padding: 3rem; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
              <div id="previewText" style="white-space: pre-wrap; word-wrap: break-word; font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif; font-size: 1rem; line-height: 1.8; color: #333;"></div>
            </div>
          </div>
          
          <div id="previewError" class="alert alert-danger m-4" style="display:none;"></div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
        </div>
      </div>
    </div>
  </div>
{% endblock %}

    {% block extra_scripts %}
    <script>
      /**
       * Refresh the files table without full page reload
       */
      function refreshFilesTable() {
        const currentUrl = window.location.pathname;
        fetch(currentUrl, {
          headers: {
            'X-Requested-With': 'XMLHttpRequest'
          }
        })
        .then(response => response.text())
        .then(html => {
          const parser = new DOMParser();
          const doc = parser.parseFromString(html, 'text/html');
          const newTable = doc.querySelector('table.table-hover');
          const currentTable = document.querySelector('table.table-hover');
          
          if (newTable && currentTable) {
            currentTable.innerHTML = newTable.innerHTML;
            // Re-attach event handlers after table update
            attachEventHandlers();
          }
        })
        .catch(error => {
          console.error('Error refreshing table:', error);
        });
      }

      /**
       * Attach all event handlers to forms
       */
      function attachEventHandlers() {
        // Toggle enable/disable via AJAX
        document.querySelectorAll('.toggle-form').forEach(function(form){
          form.addEventListener('submit', function(e){
            e.preventDefault();
            const action = form.getAttribute('action');
            fetch(action, {method: 'POST', headers: {'X-Requested-With':'XMLHttpRequest'}})
              .then(r => r.json())
              .then(data => {
                if (data.success) {
                  const btn = form.querySelector('button');
                  if (data.enabled) {
                    btn.classList.remove('btn-outline-secondary');
                    btn.classList.add('btn-outline-success');
                    btn.textContent = 'Enabled';
                  } else {
                    btn.classList.remove('btn-outline-success');
                    btn.classList.add('btn-outline-secondary');
                    btn.textContent = 'Disabled';
                  }
                }
              }).catch(console.error);
          });
        });

        // Parse via AJAX (refresh table in-place after completion)
        document.querySelectorAll('form[action*="/documents/parse/"]').forEach(function(form){
          form.addEventListener('submit', function(e){
            e.preventDefault();
            const action = form.getAttribute('action');
            const formData = new FormData(form);
            const btn = form.querySelector('button');
            const originalHTML = btn.innerHTML;
            
            // Show loading state
            btn.disabled = true;
            btn.innerHTML = '<i class="bi bi-hourglass-split"></i> Parsing...';
            
            fetch(action, {
              method: 'POST', 
              body: formData,
              headers: {'X-Requested-With':'XMLHttpRequest'}
            })
              .then(r => {
                // Parse completes - refresh table in-place
                refreshFilesTable();
              })
              .catch(err => {
                console.error(err);
                btn.disabled = false;
                btn.innerHTML = originalHTML;
                alert('Parse failed');
              });
          });
        });

        // Split via AJAX (refresh table in-place after completion)
        document.querySelectorAll('.splitter-form').forEach(function(form){
          form.addEventListener('submit', function(e){
            e.preventDefault();
            const action = form.getAttribute('action');
            const formData = new FormData(form);
            const btn = form.querySelector('button');
            const originalHTML = btn.innerHTML;
            
            // Show loading state
            btn.disabled = true;
            btn.innerHTML = '<i class="bi bi-hourglass-split"></i>';
            
            fetch(action, {
              method: 'POST', 
              body: formData,
              headers: {'X-Requested-With':'XMLHttpRequest'}
            })
              .then(r => {
                // Split completes - refresh table in-place
                refreshFilesTable();
              })
              .catch(err => {
                console.error(err);
                btn.disabled = false;
                btn.innerHTML = originalHTML;
                alert('Split failed');
              });
          });
        });

        // Embeddings via AJAX (refresh table in-place after completion)
        document.querySelectorAll('form[action*="/documents/embeddings/"]').forEach(function(form){
          form.addEventListener('submit', function(e){
            e.preventDefault();
            const action = form.getAttribute('action');
            const formData = new FormData(form);
            const btn = form.querySelector('button');
            const originalHTML = btn.innerHTML;
            
            // Show loading state
            btn.disabled = true;
            btn.innerHTML = '<i class="bi bi-hourglass-split"></i>';
            
            fetch(action, {
              method: 'POST', 
              body: formData,
              headers: {'X-Requested-With':'XMLHttpRequest'}
            })
              .then(r => {
                // Embeddings complete - refresh table in-place
                refreshFilesTable();
              })
              .catch(err => {
                console.error(err);
                btn.disabled = false;
                btn.innerHTML = originalHTML;
                alert('Embeddings generation failed');
              });
          });
        });

        // Delete via AJAX (remove row in-place)
        document.querySelectorAll('form[action*="/documents/delete/"]').forEach(function(form){
          form.addEventListener('submit', function(e){
            e.preventDefault();
            if (!confirm('Delete this file?')) return;
            const action = form.getAttribute('action');
            const btn = form.querySelector('button');
            const originalHTML = btn.innerHTML;
            
            // Show loading state
            btn.disabled = true;
            btn.innerHTML = '<i class="bi bi-hourglass-split"></i>';
            
            // Call API endpoint
            const api = action.replace('/documents/delete/', '/documents/api/delete/');
            fetch(api, {method: 'POST', headers: {'X-Requested-With':'XMLHttpRequest'}})
              .then(r => r.json())
              .then(data => {
                if (data.success) {
                  const row = form.closest('tr');
                  row.style.opacity = '0.5';
                  setTimeout(() => {
                    row.remove();
                    // Check if table is empty
                    const tbody = document.querySelector('table.table-hover tbody');
                    if (tbody.children.length === 0) {
                      tbody.innerHTML = '<tr><td colspan="8">No files uploaded yet.</td></tr>';
                    }
                  }, 300);
                } else {
                  btn.disabled = false;
                  btn.innerHTML = originalHTML;
                  alert('Delete failed');
                }
              })
              .catch(err => {
                console.error(err);
                btn.disabled = false;
                btn.innerHTML = originalHTML;
                alert('Delete failed');
              });
          });
        });
      }

      // Upload form handler
      document.addEventListener('DOMContentLoaded', function() {
        const uploadForm = document.querySelector('form[action*="/documents/upload"]');
        if (uploadForm) {
          uploadForm.addEventListener('submit', function(e) {
            e.preventDefault();
            const formData = new FormData(this);
            const btn = this.querySelector('button[type="submit"]');
            const originalHTML = btn.innerHTML;
            
            // Show loading state
            btn.disabled = true;
            btn.innerHTML = '<i class="bi bi-hourglass-split"></i> Uploading...';
            
            fetch(this.action, {
              method: 'POST',
              body: formData,
              headers: {'X-Requested-With': 'XMLHttpRequest'}
            })
            .then(response => response.json())
            .then(data => {
              if (data.success) {
                // Clear the file input
                this.reset();
                // Refresh the table to show new file
                refreshFilesTable();
              } else {
                alert(data.error || 'Upload failed');
              }
              btn.disabled = false;
              btn.innerHTML = originalHTML;
            })
            .catch(error => {
              console.error('Upload error:', error);
              alert('Upload failed');
              btn.disabled = false;
              btn.innerHTML = originalHTML;
            });
          });
        }

        // Initial event handler attachment
        attachEventHandlers();
      });

      // Document Preview Function
      function previewDocument(filename) {
        const modal = new bootstrap.Modal(document.getElementById('previewModal'));
        const loading = document.getElementById('previewLoading');
        const pdfViewer = document.getElementById('pdfViewer');
        const textContent = document.getElementById('textContent');
        const error = document.getElementById('previewError');
        const filenameDisplay = document.getElementById('previewFilename');
        
        // Reset modal state
        loading.style.display = 'block';
        pdfViewer.style.display = 'none';
        textContent.style.display = 'none';
        error.style.display = 'none';
        pdfViewer.src = '';
        
        // Set filename in title
        filenameDisplay.textContent = filename;
        
        // Show modal
        modal.show();
        
        // Check file type
        const isPDF = filename.toLowerCase().endsWith('.pdf');
        
        if (isPDF) {
          // For PDFs, load directly in iframe
          const previewUrl = `/documents/preview/${encodeURIComponent(filename)}`;
          pdfViewer.src = previewUrl;
          
          pdfViewer.onload = function() {
            loading.style.display = 'none';
            pdfViewer.style.display = 'block';
          };
          
          pdfViewer.onerror = function() {
            loading.style.display = 'none';
            error.textContent = 'Error loading PDF. The file may be corrupted or inaccessible.';
            error.style.display = 'block';
          };
        } else {
          // For non-PDF files (DOCX, TXT, etc.), fetch parsed text
          fetch(`/documents/preview/${encodeURIComponent(filename)}`)
            .then(response => response.json())
            .then(data => {
              loading.style.display = 'none';
              
              if (data.success) {
                // Format the text for better readability
                let formattedText = data.text;
                
                // Clean up excessive whitespace while preserving paragraph breaks
                formattedText = formattedText
                  .replace(/\r\n/g, '\n')  // Normalize line endings
                  .replace(/\n{3,}/g, '\n\n')  // Max 2 consecutive line breaks
                  .replace(/[ \t]+/g, ' ')  // Normalize spaces
                  .trim();
                
                // Split into paragraphs and wrap each in a div for better formatting
                const paragraphs = formattedText.split(/\n\n+/);
                const formattedHTML = paragraphs
                  .map(p => p.trim())
                  .filter(p => p.length > 0)
                  .map(p => {
                    // Check if it's a heading (all caps, short, or starts with numbers)
                    if (p.length < 100 && (p === p.toUpperCase() || /^\d+\./.test(p))) {
                      return `<h4 style="margin-top: 2rem; margin-bottom: 1rem; font-weight: 600; color: #1a1a1a;">${escapeHtml(p)}</h4>`;
                    }
                    return `<p style="margin-bottom: 1.2rem; text-align: justify;">${escapeHtml(p)}</p>`;
                  })
                  .join('');
                
                document.getElementById('previewText').innerHTML = formattedHTML;
                textContent.style.display = 'block';
              } else {
                error.textContent = data.message || 'Failed to load preview';
                error.style.display = 'block';
              }
            })
            .catch(err => {
              console.error('Preview error:', err);
              loading.style.display = 'none';
              error.textContent = 'Error loading document preview';
              error.style.display = 'block';
            });
        }
      }
      
      // Helper to escape HTML
      function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }
      
      // Helper function to format file size
      function formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
      }
    </script>
    {% endblock %}

